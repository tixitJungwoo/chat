'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ByPassRetryError = exports.MaxRetryError = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.default = retry;

var _util = require('util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// default options
var options = {
  maxRetries: 4,
  timeFunction: function timeFunction(i) {
    return 100 * Math.pow(i, 2);
  }
};

// XXX: We we need to use instanceof with these error classes.
// So, we can't use Babel's version of extends for that.
// It's doesn't support that. See: http://stackoverflow.com/a/33877501/457224
// That's why we are doing it in the old fashion way.

// reject the promise with this error when run out of retry attmpts.
var MaxRetryError = exports.MaxRetryError = function MaxRetryError(message) {
  Error.call(this, message);
  this.message = message;
};
(0, _util.inherits)(MaxRetryError, Error);

// reject the promise with this error (in promiser) to stop retrying.
var ByPassRetryError = exports.ByPassRetryError = function ByPassRetryError(message) {
  Error.call(this, message);
  this.message = message;
};
(0, _util.inherits)(MaxRetryError, Error);

// retry([options], fn)
// retry module takes a `promiser` function as the main argument.
// The promiser function should return a promise which will be used
// to decide whether the task ran successfully. If the task failed
// it will retry by running the `promiser` function again. Retry will
// stop when it has tried `maxRetries` times or if the promise fails
// with the special error `ERR_ENDRETRY`.
function retry(promiser) {
  // The retry module returns a promise which will end when the task
  // is successful or when the retry fails by retry count or by user.
  // It will also collect start/end times for each retry attempt.
  return new _promise2.default(function (resolve, reject) {
    var count = 0;

    var onError = function onError(err) {
      if (err instanceof ByPassRetryError) {
        reject(err);
      } else {
        attempt(err);
      }
    };

    var attempt = function () {
      var ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(lastError) {
        var message, err, millis;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(++count > options.maxRetries)) {
                  _context.next = 4;
                  break;
                }

                message = 'Reached maximum retry limit for ' + lastError.message;
                err = new MaxRetryError(message);
                return _context.abrupt('return', reject(err));

              case 4:

                // stop a few milliseconds between retries
                millis = options.timeFunction(count);
                _context.next = 7;
                return delay(millis);

              case 7:

                promiser().then(resolve, onError);

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      return function attempt(_x) {
        return ref.apply(this, arguments);
      };
    }();

    // start!
    attempt();
  });
}

function delay(millis) {
  return new _promise2.default(function (resolve) {
    setTimeout(resolve, millis);
  });
}