{"version":3,"sources":["meteor://💻app/packages/todda00_friendly-slugs/slugs.coffee","meteor://💻app/slugs.coffee.js"],"names":["Mongo","slugify","stringToNested","Collection","Meteor","prototype","friendlySlugs","options","collection","fsDebug","runSlug","_","isArray","each","opts","defaults","fields","isString","slugFrom","slugField","distinct","distinctUpTo","updateSlug","createOnUpdate","maxLength","debug","transliteration","from","to","Array","String","Boolean","Number","check","Match","ObjectIncluding","before","insert","userId","doc","update","fieldNames","modifier","cleanModifier","cont","slugFromChanged","isEmpty","$set","multi","docFrom","create","baseField","combineFrom","defaultSlugGenerator","f","fieldSelector","finalSlug","i","index","indexField","limitSelector","ref","result","slugBase","slugGenerator","sortSelector","modifierDoc","fromValues","val","push","length","join","replace","findOne","sort","limit","base","item","label","console","log","text","lastDash","slug","toString","toLowerCase","RegExp","substring","lastIndexOf","obj","path","parts","split","slice"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAAA,KAAA,EAAAC,OAAA,EAAAC,cAAA;;AAAA,IAAG,OAAOF,KAAP,KAAgB,WAAnB;AACEA,UAAQ,EAAR;AACAA,QAAMG,UAAN,GAAmBC,OAAOD,UAA1B;ACED;;ADADH,MAAMG,UAAN,CAAiBE,SAAjB,CAA2BC,aAA3B,GAA2C,UAACC,OAAD;AACzC,MAAAC,UAAA,EAAAC,OAAA,EAAAC,OAAA;;ACGA,MAAIH,WAAW,IAAf,EAAqB;ADJqBA,cAAU,EAAV;ACMzC;;ADLDC,eAAa,IAAb;;AAEA,MAAG,CAACG,EAAEC,OAAF,CAAUL,OAAV,CAAJ;AACEA,cAAU,CAACA,OAAD,CAAV;ACMD;;ADJDI,IAAEE,IAAF,CAAON,OAAP,EAAgB,UAACO,IAAD;AACd,QAAAC,QAAA,EAAAC,MAAA;;AAAA,QAAGL,EAAEM,QAAF,CAAWH,IAAX,CAAH;AACEA,aAAO;AACLI,kBAAU,CAACJ,IAAD;AADL,OAAP;ACSD;;ADND,QAAmCH,EAAEM,QAAF,CAAWH,KAAKI,QAAhB,CAAnC;AAAAJ,WAAKI,QAAL,GAAgB,CAACJ,KAAKI,QAAN,CAAhB;ACSC;;ADPDH,eACE;AAAAG,gBAAU,CAAC,MAAD,CAAV;AACAC,iBAAW,MADX;AAEAC,gBAAU,IAFV;AAGAC,oBAAc,EAHd;AAIAC,kBAAY,IAJZ;AAKAC,sBAAgB,IALhB;AAMAC,iBAAW,CANX;AAOAC,aAAO,KAPP;AAQAC,uBAAiB,CACf;AAACC,cAAM,SAAP;AAAkBC,YAAI;AAAtB,OADe,EAEf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAFe,EAGf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAHe,EAIf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAJe,EAKf;AAACD,cAAM,SAAP;AAAiBC,YAAI;AAArB,OALe,EAMf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OANe,EAOf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAPe,EAQf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OARe,EASf;AAACD,cAAM,OAAP;AAAiBC,YAAI;AAArB,OATe,EAUf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAVe,EAWf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAXe,EAYf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAZe,EAaf;AAACD,cAAM,IAAP;AAAiBC,YAAI;AAArB,OAbe,EAcf;AAACD,cAAM,QAAP;AAAiBC,YAAI;AAArB,OAde,EAef;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAfe,EAgBf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAhBe,EAiBf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAjBe,EAkBf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAlBe,EAmBf;AAACD,cAAM,OAAP;AAAiBC,YAAI;AAArB,OAnBe,EAoBf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OApBe,EAqBf;AAACD,cAAM,IAAP;AAAiBC,YAAI;AAArB,OArBe,EAsBf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAtBe,EAuBf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAvBe,EAwBf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAxBe,EAyBf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OAzBe,EA0Bf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OA1Be,EA2Bf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OA3Be,EA4Bf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OA5Be,EA6Bf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OA7Be,EA8Bf;AAACD,cAAM,GAAP;AAAiBC,YAAI;AAArB,OA9Be,EA+Bf;AAACD,cAAM,IAAP;AAAiBC,YAAI;AAArB,OA/Be;AARjB,KADF;;AA2CAjB,MAAEI,QAAF,CAAWD,IAAX,EAAiBC,QAAjB;;AAEAC,aACE;AAAAE,gBAAUW,KAAV;AACAV,iBAAWW,MADX;AAEAV,gBAAUW,OAFV;AAGAR,sBAAgBQ,OAHhB;AAIAP,iBAAWQ,MAJX;AAKAP,aAAOM;AALP,KADF;;AAQA,QAAG,OAAOjB,KAAKQ,UAAZ,KAA0B,UAA7B;AACE,UAAIR,KAAKQ,UAAT;AACER,aAAKQ,UAAL,GAAkB;ACuEhB,iBDvEsB,ICuEtB;ADvEgB,SAAlB;AADF;AAGER,aAAKQ,UAAL,GAAkB;ACyEhB,iBDzEsB,KCyEtB;ADzEgB,SAAlB;AAJJ;ACgFC;;ADzEDW,UAAMnB,IAAN,EAAWoB,MAAMC,eAAN,CAAsBnB,MAAtB,CAAX;AAEAR,eAAW4B,MAAX,CAAkBC,MAAlB,CAAyB,UAACC,MAAD,EAASC,GAAT;AACvB9B,cAAQK,IAAR,EAAa,wBAAb;AACAJ,cAAQ6B,GAAR,EAAYzB,IAAZ;AAFF;AAKAN,eAAW4B,MAAX,CAAkBI,MAAlB,CAAyB,UAACF,MAAD,EAASC,GAAT,EAAcE,UAAd,EAA0BC,QAA1B,EAAoCnC,OAApC;AACvB,UAAAoC,aAAA,EAAAC,IAAA,EAAAC,eAAA;AAAApC,cAAQK,IAAR,EAAa,wBAAb;;AACA6B,sBAAgB;AAEd,YAAwBhC,EAAEmC,OAAF,CAAUJ,SAASK,IAAnB,CAAxB;ACyEE,iBDzEF,OAAOL,SAASK,ICyEd;AACD;AD5Ea,OAAhB;;AAKAxC,gBAAUA,WAAW,EAArB;;AACA,UAAGA,QAAQyC,KAAX;AACEvC,gBAAQK,IAAR,EAAa,mEAAb;AACA,eAAO,IAAP;AC0ED;;ADxED4B,iBAAWA,YAAY,EAAvB;AACAA,eAASK,IAAT,GAAgBL,SAASK,IAAT,IAAiB,EAAjC;AAGAH,aAAO,KAAP;;AACAjC,QAAEE,IAAF,CAAOC,KAAKI,QAAZ,EAAsB,UAACA,QAAD;AACpB,YAAehB,eAAeqC,GAAf,EAAoBrB,QAApB,KAAiCwB,SAAAK,IAAA,CAAA7B,QAAA,SAAjC,IAA6DhB,eAAewC,SAASK,IAAxB,EAA8B7B,QAA9B,CAA5E;ACwEE,iBDxEF0B,OAAO,ICwEL;AACD;AD1EH;;AAEA,UAAG,CAACA,IAAJ;AACEnC,gBAAQK,IAAR,EAAa,0EAAb;AACA6B;AACA,eAAO,IAAP;AC2ED;;ADxEDE,wBAAkB,KAAlB;;AACAlC,QAAEE,IAAF,CAAOC,KAAKI,QAAZ,EAAsB,UAACA,QAAD;AACpB,YAAA+B,OAAA;;AAAA,YAAGP,SAAAK,IAAA,CAAA7B,QAAA,aAA4BhB,eAAewC,SAASK,IAAxB,EAA8B7B,QAA9B,CAA/B;AACE+B,oBAAU/C,eAAeqC,GAAf,EAAoBrB,QAApB,CAAV;;AACA,cAAI+B,YAAaP,SAASK,IAAT,CAAc7B,QAAd,CAAd,IAA4C+B,YAAa/C,eAAewC,SAASK,IAAxB,EAA8B7B,QAA9B,CAA5D;AC2EE,mBD1EA2B,kBAAkB,IC0ElB;AD7EJ;AC+EC;ADhFH;;AAMApC,cAAQK,IAAR,EAAa+B,eAAb,EAA6B,iBAA7B;;AAGA,UAAG,CAAC3C,eAAeqC,GAAf,EAAoBzB,KAAKK,SAAzB,CAAD,IAAyCL,KAAKS,cAAjD;AACEd,gBAAQK,IAAR,EAAa,iEAAb;;AAEA,YAAG+B,eAAH;AACEpC,kBAAQK,IAAR,EAAa,mDAAb;AACAJ,kBAAQ6B,GAAR,EAAazB,IAAb,EAAmB4B,QAAnB;AAFF;AAKEjC,kBAAQK,IAAR,EAAa,mBAAb;AACAJ,kBAAQ6B,GAAR,EAAazB,IAAb,EAAmB4B,QAAnB,EAA6B,IAA7B;AACAC;AACA,iBAAO,IAAP;AAXJ;AAAA;AAeE,oBAAA7B,KAAAQ,UAAA,kBAAGR,KAAKQ,UAAL,CAAiBiB,GAAjB,EAAsBG,QAAtB,CAAH,GAAyB,MAAzB,MAAsC,KAAtC;AACEjC,kBAAQK,IAAR,EAAa,qCAAb;AACA6B;AACA,iBAAO,IAAP;ACwED;;ADrED,YAAG,CAACE,eAAJ;AACEpC,kBAAQK,IAAR,EAAa,gDAAb;AACA6B;AACA,iBAAO,IAAP;ACuED;;ADrEDjC,gBAAQ6B,GAAR,EAAazB,IAAb,EAAmB4B,QAAnB;AAEAC;AACA,eAAO,IAAP;ACsED;;ADpEDA;AACA,aAAO,IAAP;AAnEF;AA1EF;;AA+IAjC,YAAU,UAAC6B,GAAD,EAAMzB,IAAN,EAAY4B,QAAZ,EAA8BQ,MAA9B;AACR,QAAAC,SAAA,EAAAC,WAAA,EAAAC,oBAAA,EAAAC,CAAA,EAAAC,aAAA,EAAAC,SAAA,EAAA7B,IAAA,EAAA8B,CAAA,EAAAC,KAAA,EAAAC,UAAA,EAAAC,aAAA,EAAAC,GAAA,EAAAC,MAAA,EAAAC,QAAA,EAAAC,aAAA,EAAAC,YAAA;;ACuEA,QAAIvB,YAAY,IAAhB,EAAsB;ADxEFA,iBAAW,KAAX;AC0EnB;;AACD,QAAIQ,UAAU,IAAd,EAAoB;AD3EkBA,eAAS,KAAT;AC6ErC;;AD5EDzC,YAAQK,IAAR,EAAa,eAAb;AACAL,YAAQK,IAAR,EAAaA,IAAb,EAAkB,SAAlB;AACAL,YAAQK,IAAR,EAAa4B,QAAb,EAAuB,UAAvB;AACAjC,YAAQK,IAAR,EAAaoC,MAAb,EAAoB,QAApB;;AAEAE,kBAAc,UAACb,GAAD,EAAMvB,MAAN,EAAckD,WAAd;AACZ,UAAAC,UAAA;AAAAA,mBAAa,EAAb;;AACAxD,QAAEE,IAAF,CAAOG,MAAP,EAAe,UAACsC,CAAD;AACb,YAAAc,GAAA;;AAAA,YAAGF,eAAA,IAAH;AACE,cAAGhE,eAAegE,WAAf,EAA4BZ,CAA5B,CAAH;AACEc,kBAAMlE,eAAegE,WAAf,EAA4BZ,CAA5B,CAAN;AADF;AAGEc,kBAAMlE,eAAeqC,GAAf,EAAoBe,CAApB,CAAN;AAJJ;AAAA;AAMEc,gBAAMlE,eAAeqC,GAAf,EAAoBe,CAApB,CAAN;ACgFD;;AD/ED,YAAwBc,GAAxB;ACiFE,iBDjFFD,WAAWE,IAAX,CAAgBD,GAAhB,CCiFE;AACD;AD1FH;;AASA,UAAgBD,WAAWG,MAAX,KAAqB,CAArC;AAAA,eAAO,KAAP;ACqFC;;ADpFD,aAAOH,WAAWI,IAAX,CAAgB,GAAhB,CAAP;AAZY,KAAd;;AAcA5C,WAAUuB,UAAU,CAACR,QAAX,GAAyBU,YAAYb,GAAZ,EAAiBzB,KAAKI,QAAtB,CAAzB,GAA8DkC,YAAYb,GAAZ,EAAiBzB,KAAKI,QAAtB,EAAgCwB,SAASK,IAAzC,CAAxE;;AAEA,QAAGpB,SAAQ,KAAX;AACElB,cAAQK,IAAR,EAAa,gCAAb;AACA,aAAO,IAAP;ACqFD;;ADnFDL,YAAQK,IAAR,EAAaa,IAAb,EAAkB,eAAlB;AAEAoC,eAAW9D,QAAQ0B,IAAR,EAAcb,KAAKY,eAAnB,EAAoCZ,KAAKU,SAAzC,CAAX;;AACA,QAAgB,CAACuC,QAAjB;AAAA,aAAO,KAAP;ACqFC;;ADnFDtD,YAAQK,IAAR,EAAaiD,QAAb,EAAsB,2BAAtB;;AAEA,QAAGjD,KAAKM,QAAR;AAGE2C,iBAAWA,SAASS,OAAT,CAAiB,UAAjB,EAA4B,EAA5B,CAAX;AACA/D,cAAQK,IAAR,EAAaiD,QAAb,EAAsB,0BAAtB;AAEAZ,kBAAY,mBAAmBrC,KAAKK,SAAxB,GAAoC,OAAhD;AACAwC,mBAAa,mBAAmB7C,KAAKK,SAAxB,GAAoC,QAAjD;AAEAoC,sBAAgB,EAAhB;AACAA,oBAAcJ,SAAd,IAA2BY,QAA3B;AAEAN,UAAI,CAAJ;;AACA,aAAMA,IAAI3C,KAAKO,YAAL,CAAkBiD,MAA5B;AACEhB,YAAIxC,KAAKO,YAAL,CAAkBoC,CAAlB,CAAJ;AACAF,sBAAcD,CAAd,IAAmBf,IAAIe,CAAJ,CAAnB;AACAG;AAHF;;AAKAQ,qBAAe,EAAf;AACAA,mBAAaN,UAAb,IAA2B,CAAC,CAA5B;AAEAC,sBAAgB,EAAhB;AACAA,oBAAcD,UAAd,IAA4B,CAA5B;AAEAG,eAAStD,WAAWiE,OAAX,CAAmBlB,aAAnB,EACP;AAAAmB,cAAMT,YAAN;AACAjD,gBAAQ4C,aADR;AAEAe,eAAM;AAFN,OADO,CAAT;AAMAlE,cAAQK,IAAR,EAAagD,MAAb,EAAoB,4BAApB;;AAEA,UAAIA,UAAA,QAAYA,OAAAxD,aAAA,QAAZ,IAAsCwD,OAAAxD,aAAA,CAAAQ,KAAAK,SAAA,SAAtC,IAAgF2C,OAAAxD,aAAA,CAAAQ,KAAAK,SAAA,EAAAuC,KAAA,QAApF;AACEA,gBAAQ,CAAR;AADF;AAGEA,gBAAQI,OAAOxD,aAAP,CAAqBQ,KAAKK,SAA1B,EAAqCuC,KAArC,GAA6C,CAArD;AC2ED;;ADzEDL,6BAAuB,UAACU,QAAD,EAAWL,KAAX;AACrB,YAAGA,UAAS,CAAZ;AC2EE,iBD3EiBK,QC2EjB;AD3EF;AC6EE,iBD7E+BA,WAAW,GAAX,GAAiBL,KC6EhD;AACD;AD/EoB,OAAvB;;AAGAM,sBAAA,CAAAH,MAAA/C,KAAAkD,aAAA,YAAAH,GAAA,GAAqCR,oBAArC;AAEAG,kBAAYQ,cAAcD,QAAd,EAAwBL,KAAxB,CAAZ;AA1CF;AA8CEA,cAAQ,KAAR;AACAF,kBAAYO,QAAZ;AC4ED;;AD1EDtD,YAAQK,IAAR,EAAa0C,SAAb,EAAuB,WAAvB;;AAEA,QAAGd,YAAYQ,MAAf;AACEzC,cAAQK,IAAR,EAAa,wCAAb;AACA4B,iBAAWA,YAAY,EAAvB;AACAA,eAASK,IAAT,GAAgBL,SAASK,IAAT,IAAiB,EAAjC;AACAL,eAASK,IAAT,CAAczC,aAAd,GAA8BiC,IAAIjC,aAAJ,IAAqB,EAAnD;AACAoC,eAASK,IAAT,CAAczC,aAAd,CAA4BQ,KAAKK,SAAjC,IAA8CuB,SAASK,IAAT,CAAczC,aAAd,CAA4BQ,KAAKK,SAAjC,KAA+C,EAA7F;AACAuB,eAASK,IAAT,CAAczC,aAAd,CAA4BQ,KAAKK,SAAjC,EAA4CyD,IAA5C,GAAmDb,QAAnD;AACArB,eAASK,IAAT,CAAczC,aAAd,CAA4BQ,KAAKK,SAAjC,EAA4CuC,KAA5C,GAAoDA,KAApD;AACAhB,eAASK,IAAT,CAAcjC,KAAKK,SAAnB,IAAgCqC,SAAhC;AACA/C,cAAQK,IAAR,EAAa4B,QAAb,EAAsB,gBAAtB;AATF;AAYEjC,cAAQK,IAAR,EAAa,eAAb;AACAyB,UAAIjC,aAAJ,GAAoBiC,IAAIjC,aAAJ,IAAqB,EAAzC;AACAiC,UAAIjC,aAAJ,CAAkBQ,KAAKK,SAAvB,IAAoCoB,IAAIjC,aAAJ,CAAkBQ,KAAKK,SAAvB,KAAqC,EAAzE;AACAoB,UAAIjC,aAAJ,CAAkBQ,KAAKK,SAAvB,EAAkCyD,IAAlC,GAAyCb,QAAzC;AACAxB,UAAIjC,aAAJ,CAAkBQ,KAAKK,SAAvB,EAAkCuC,KAAlC,GAA0CA,KAA1C;AACAnB,UAAIzB,KAAKK,SAAT,IAAsBqC,SAAtB;AACA/C,cAAQK,IAAR,EAAayB,GAAb,EAAiB,WAAjB;AC0ED;;ADzED,WAAO,IAAP;AAvGQ,GAAV;;ACmLA,SD1EA9B,UAAU,UAACK,IAAD,EAAO+D,IAAP,EAAaC,KAAb;AC2ER,QAAIA,SAAS,IAAb,EAAmB;AD3EEA,cAAQ,EAAR;AC6EpB;;AD5ED,QAAU,CAAChE,KAAKW,KAAhB;AAAA;AC+EC;;AD9ED,QAAG,QAAOoD,IAAP,yCAAOA,IAAP,OAAe,QAAlB;AACEE,cAAQC,GAAR,CAAY,0BAA0BF,KAA1B,GAAkC,GAA9C;ACgFA,aD/EAC,QAAQC,GAAR,CAAYH,IAAZ,CC+EA;ADjFF;ACmFE,aD/EAE,QAAQC,GAAR,CAAY,0BAA0BF,KAA1B,GAAkC,IAAlC,GAAyCD,IAArD,CC+EA;AACD;ADtFO,GC0EV;ADxUyC,CAA3C;;AAsQA5E,UAAU,UAACgF,IAAD,EAAOvD,eAAP,EAAwBF,SAAxB;AACR,MAAA0D,QAAA,EAAAC,IAAA;;AAAA,MAAiBF,QAAA,IAAjB;AAAA,WAAO,KAAP;ACqFC;;ADpFD,MAAgBA,KAAKX,MAAL,GAAc,CAA9B;AAAA,WAAO,KAAP;ACuFC;;ADtFDW,SAAOA,KAAKG,QAAL,GAAgBC,WAAhB,EAAP;;AACA1E,IAAEE,IAAF,CAAOa,eAAP,EAAwB,UAACmD,IAAD;ACwFtB,WDvFAI,OAAOA,KAAKT,OAAL,CAAiB,IAAAc,MAAA,CAAO,MAAIT,KAAKlD,IAAT,GAAc,GAArB,EAAyB,GAAzB,CAAjB,EAA+CkD,KAAKjD,EAApD,CCuFP;ADxFF;;AAEAuD,SAAOF,KACJT,OADI,CACI,IADJ,EACU,EADV,EAEJA,OAFI,CAEI,aAFJ,EAEmB,GAFnB,EAGJA,OAHI,CAGI,QAHJ,EAGc,GAHd,EAIJA,OAJI,CAII,KAJJ,EAIW,EAJX,EAKJA,OALI,CAKI,KALJ,EAKW,EALX,CAAP;;AAMA,MAAGhD,YAAY,CAAZ,IAAiB2D,KAAKb,MAAL,GAAc9C,SAAlC;AACE0D,eAAWC,KAAKI,SAAL,CAAe,CAAf,EAAiB/D,SAAjB,EAA4BgE,WAA5B,CAAwC,GAAxC,CAAX;AACAL,WAAOA,KAAKI,SAAL,CAAe,CAAf,EAAiBL,QAAjB,CAAP;ACoFD;;ADnFD,SAAOC,IAAP;AAfQ,CAAV;;AAiBAjF,iBAAiB,UAACuF,GAAD,EAAMC,IAAN;AACf,MAAAC,KAAA;AAAAA,UAAQD,KAAKE,KAAL,CAAW,GAAX,CAAR;;AACA,MAAGD,MAAMrB,MAAN,KAAc,CAAjB;AACE,QAAGmB,OAAA,QAAQA,IAAAE,MAAA,WAAX;AACE,aAAOF,IAAIE,MAAM,CAAN,CAAJ,CAAP;AADF;AAGE,aAAO,KAAP;AAJJ;AC4FC;;ADvFD,SAAOzF,eAAeuF,IAAIE,MAAM,CAAN,CAAJ,CAAf,EAA8BA,MAAME,KAAN,CAAY,CAAZ,EAAetB,IAAf,CAAoB,GAApB,CAA9B,CAAP;AAPe,CAAjB,wH","file":"/packages/todda00_friendly-slugs.js","sourcesContent":["# backwards compatibility\nif typeof Mongo is \"undefined\"\n  Mongo = {}\n  Mongo.Collection = Meteor.Collection\n\nMongo.Collection.prototype.friendlySlugs = (options = {}) ->\n  collection = @\n\n  if !_.isArray(options)\n    options = [options]\n\n  _.each options, (opts) ->\n    if _.isString(opts)\n      opts = {\n        slugFrom: [opts]\n      }\n    opts.slugFrom = [opts.slugFrom] if _.isString opts.slugFrom\n\n    defaults =\n      slugFrom: ['name']\n      slugField: 'slug'\n      distinct: true\n      distinctUpTo: []\n      updateSlug: true\n      createOnUpdate: true\n      maxLength: 0\n      debug: false\n      transliteration: [\n        {from: 'àáâäåãа', to: 'a'}\n        {from: 'б',      to: 'b'}\n        {from: 'ç',      to: 'c'}\n        {from: 'д',      to: 'd'}\n        {from: 'èéêëẽэе',to: 'e'}\n        {from: 'ф',      to: 'f'}\n        {from: 'г',      to: 'g'}\n        {from: 'х',      to: 'h'}\n        {from: 'ìíîïи',  to: 'i'}\n        {from: 'к',      to: 'k'}\n        {from: 'л',      to: 'l'}\n        {from: 'м',      to: 'm'}\n        {from: 'ñн',     to: 'n'}\n        {from: 'òóôöõо', to: 'o'}\n        {from: 'п',      to: 'p'}\n        {from: 'р',      to: 'r'}\n        {from: 'с',      to: 's'}\n        {from: 'т',      to: 't'}\n        {from: 'ùúûüу',  to: 'u'}\n        {from: 'в',      to: 'v'}\n        {from: 'йы',     to: 'y'}\n        {from: 'з',      to: 'z'}\n        {from: 'æ',      to: 'ae'}\n        {from: 'ч',      to: 'ch'}\n        {from: 'щ',      to: 'sch'}\n        {from: 'ш',      to: 'sh'}\n        {from: 'ц',      to: 'ts'}\n        {from: 'я',      to: 'ya'}\n        {from: 'ю',      to: 'yu'}\n        {from: 'ж',      to: 'zh'}\n        {from: 'ъь',     to: ''}\n      ]\n\n    _.defaults(opts, defaults)\n\n    fields =\n      slugFrom: Array\n      slugField: String\n      distinct: Boolean\n      createOnUpdate: Boolean\n      maxLength: Number\n      debug: Boolean\n\n    if typeof opts.updateSlug != \"function\"\n      if (opts.updateSlug)\n        opts.updateSlug = () -> true\n      else\n        opts.updateSlug = () -> false\n\n\n    check(opts,Match.ObjectIncluding(fields))\n\n    collection.before.insert (userId, doc) ->\n      fsDebug(opts,'before.insert function')\n      runSlug(doc,opts)\n      return\n\n    collection.before.update (userId, doc, fieldNames, modifier, options) ->\n      fsDebug(opts,'before.update function')\n      cleanModifier = () ->\n        #Cleanup the modifier if needed\n        delete modifier.$set if _.isEmpty(modifier.$set)\n\n      #Don't do anything if this is a multi doc update\n      options = options || {}\n      if options.multi\n        fsDebug(opts,\"multi doc update attempted, can't update slugs this way, leaving.\")\n        return true\n\n      modifier = modifier || {}\n      modifier.$set = modifier.$set || {}\n\n      #Don't do anything if all the slugFrom fields aren't present (before or after update)\n      cont = false\n      _.each opts.slugFrom, (slugFrom) ->\n        cont = true if stringToNested(doc, slugFrom) || modifier.$set[slugFrom]? || stringToNested(modifier.$set, slugFrom)\n      if !cont\n        fsDebug(opts,\"no slugFrom fields are present (either before or after update), leaving.\")\n        cleanModifier()\n        return true\n\n      #See if any of the slugFrom fields have changed\n      slugFromChanged = false\n      _.each opts.slugFrom, (slugFrom) ->\n        if modifier.$set[slugFrom]? || stringToNested(modifier.$set, slugFrom)\n          docFrom = stringToNested(doc, slugFrom)\n          if (docFrom isnt modifier.$set[slugFrom]) and (docFrom isnt stringToNested(modifier.$set, slugFrom))\n            slugFromChanged = true\n\n      fsDebug(opts,slugFromChanged,'slugFromChanged')\n\n      #Is the slug missing / Is this an existing item we have added a slug to? AND are we supposed to create a slug on update?\n      if !stringToNested(doc, opts.slugField) and opts.createOnUpdate\n        fsDebug(opts,'Update: Slug Field is missing and createOnUpdate is set to true')\n\n        if slugFromChanged\n          fsDebug(opts,'slugFrom field has changed, runSlug with modifier')\n          runSlug(doc, opts, modifier)\n        else\n          #Run the slug to create\n          fsDebug(opts,'runSlug to create')\n          runSlug(doc, opts, modifier, true)\n          cleanModifier()\n          return true\n\n      else\n        # Don't change anything on update if updateSlug is false\n        if opts.updateSlug?(doc, modifier) is false\n          fsDebug(opts,'updateSlug is false, nothing to do.')\n          cleanModifier()\n          return true\n\n        #Don't do anything if the slug from field has not changed\n        if !slugFromChanged\n          fsDebug(opts,'slugFrom field has not changed, nothing to do.')\n          cleanModifier()\n          return true\n\n        runSlug(doc, opts, modifier)\n\n        cleanModifier()\n        return true\n\n      cleanModifier()\n      return true\n    return\n  runSlug = (doc, opts, modifier = false, create = false) ->\n    fsDebug(opts,'Begin runSlug')\n    fsDebug(opts,opts,'Options')\n    fsDebug(opts,modifier, 'Modifier')\n    fsDebug(opts,create,'Create')\n\n    combineFrom = (doc, fields, modifierDoc) ->\n      fromValues = []\n      _.each fields, (f) ->\n        if modifierDoc?\n          if stringToNested(modifierDoc, f)\n            val = stringToNested(modifierDoc, f)\n          else\n            val = stringToNested(doc, f)\n        else\n          val = stringToNested(doc, f)\n        fromValues.push(val) if val\n      return false if fromValues.length == 0\n      return fromValues.join('-')\n\n    from = if create or !modifier then combineFrom(doc, opts.slugFrom) else combineFrom(doc, opts.slugFrom, modifier.$set)\n\n    if from == false\n      fsDebug(opts,\"Nothing to slug from, leaving.\")\n      return true\n\n    fsDebug(opts,from,'Slugging From')\n\n    slugBase = slugify(from, opts.transliteration, opts.maxLength)\n    return false if !slugBase\n\n    fsDebug(opts,slugBase,'SlugBase before reduction')\n\n    if opts.distinct\n\n      # Check to see if this base has a -[0-9999...] at the end, reduce to a real base\n      slugBase = slugBase.replace(/(-\\d+)+$/,'')\n      fsDebug(opts,slugBase,'SlugBase after reduction')\n\n      baseField = \"friendlySlugs.\" + opts.slugField + \".base\"\n      indexField = \"friendlySlugs.\" + opts.slugField + \".index\"\n\n      fieldSelector = {}\n      fieldSelector[baseField] = slugBase\n\n      i = 0\n      while i < opts.distinctUpTo.length\n        f = opts.distinctUpTo[i]\n        fieldSelector[f] = doc[f]\n        i++\n\n      sortSelector = {}\n      sortSelector[indexField] = -1\n\n      limitSelector = {}\n      limitSelector[indexField] = 1\n\n      result = collection.findOne(fieldSelector,\n        sort: sortSelector\n        fields: limitSelector\n        limit:1\n      )\n\n      fsDebug(opts,result,'Highest indexed base found')\n\n      if !result? || !result.friendlySlugs? || !result.friendlySlugs[opts.slugField]? || !result.friendlySlugs[opts.slugField].index?\n        index = 0\n      else\n        index = result.friendlySlugs[opts.slugField].index + 1\n\n      defaultSlugGenerator = (slugBase, index) ->\n        if index is 0 then slugBase else slugBase + '-' + index\n\n      slugGenerator = opts.slugGenerator ? defaultSlugGenerator\n\n      finalSlug = slugGenerator(slugBase, index)\n\n    else\n      #Not distinct, just set the base\n      index = false\n      finalSlug = slugBase\n\n    fsDebug(opts,finalSlug,'finalSlug')\n\n    if modifier or create\n      fsDebug(opts,'Set to modify or create slug on update')\n      modifier = modifier || {}\n      modifier.$set = modifier.$set || {}\n      modifier.$set.friendlySlugs = doc.friendlySlugs || {}\n      modifier.$set.friendlySlugs[opts.slugField] = modifier.$set.friendlySlugs[opts.slugField] || {}\n      modifier.$set.friendlySlugs[opts.slugField].base = slugBase\n      modifier.$set.friendlySlugs[opts.slugField].index = index\n      modifier.$set[opts.slugField] = finalSlug\n      fsDebug(opts,modifier,'Final Modifier')\n\n    else\n      fsDebug(opts,'Set to update')\n      doc.friendlySlugs = doc.friendlySlugs || {}\n      doc.friendlySlugs[opts.slugField] = doc.friendlySlugs[opts.slugField] || {}\n      doc.friendlySlugs[opts.slugField].base = slugBase\n      doc.friendlySlugs[opts.slugField].index = index\n      doc[opts.slugField] = finalSlug\n      fsDebug(opts,doc,'Final Doc')\n    return true\n\n  fsDebug = (opts, item, label = '')->\n    return if !opts.debug\n    if typeof item is 'object'\n      console.log \"friendlySlugs DEBUG: \" + label + '↓'\n      console.log item\n    else\n      console.log \"friendlySlugs DEBUG: \" + label + '= ' + item\n\nslugify = (text, transliteration, maxLength) ->\n  return false if !text?\n  return false if text.length < 1\n  text = text.toString().toLowerCase()\n  _.each transliteration, (item)->\n    text = text.replace(new RegExp('['+item.from+']','g'),item.to)\n  slug = text\n    .replace(/'/g, '')              # Remove all apostrophes\n    .replace(/[^0-9a-z-]/g, '-')    # Replace anything that is not 0-9, a-z, or - with -\n    .replace(/\\-\\-+/g, '-')         # Replace multiple - with single -\n    .replace(/^-+/, '')             # Trim - from start of text\n    .replace(/-+$/, '');            # Trim - from end of text\n  if maxLength > 0 && slug.length > maxLength\n    lastDash = slug.substring(0,maxLength).lastIndexOf('-')\n    slug = slug.substring(0,lastDash)\n  return slug\n\nstringToNested = (obj, path) ->\n  parts = path.split(\".\")\n  if parts.length==1\n    if obj? && obj[parts[0]]?\n      return obj[parts[0]]\n    else\n      return false\n  return stringToNested(obj[parts[0]], parts.slice(1).join(\".\"))\n","var Mongo, slugify, stringToNested;\n\nif (typeof Mongo === \"undefined\") {\n  Mongo = {};\n  Mongo.Collection = Meteor.Collection;\n}\n\nMongo.Collection.prototype.friendlySlugs = function(options) {\n  var collection, fsDebug, runSlug;\n  if (options == null) {\n    options = {};\n  }\n  collection = this;\n  if (!_.isArray(options)) {\n    options = [options];\n  }\n  _.each(options, function(opts) {\n    var defaults, fields;\n    if (_.isString(opts)) {\n      opts = {\n        slugFrom: [opts]\n      };\n    }\n    if (_.isString(opts.slugFrom)) {\n      opts.slugFrom = [opts.slugFrom];\n    }\n    defaults = {\n      slugFrom: ['name'],\n      slugField: 'slug',\n      distinct: true,\n      distinctUpTo: [],\n      updateSlug: true,\n      createOnUpdate: true,\n      maxLength: 0,\n      debug: false,\n      transliteration: [\n        {\n          from: 'àáâäåãа',\n          to: 'a'\n        }, {\n          from: 'б',\n          to: 'b'\n        }, {\n          from: 'ç',\n          to: 'c'\n        }, {\n          from: 'д',\n          to: 'd'\n        }, {\n          from: 'èéêëẽэе',\n          to: 'e'\n        }, {\n          from: 'ф',\n          to: 'f'\n        }, {\n          from: 'г',\n          to: 'g'\n        }, {\n          from: 'х',\n          to: 'h'\n        }, {\n          from: 'ìíîïи',\n          to: 'i'\n        }, {\n          from: 'к',\n          to: 'k'\n        }, {\n          from: 'л',\n          to: 'l'\n        }, {\n          from: 'м',\n          to: 'm'\n        }, {\n          from: 'ñн',\n          to: 'n'\n        }, {\n          from: 'òóôöõо',\n          to: 'o'\n        }, {\n          from: 'п',\n          to: 'p'\n        }, {\n          from: 'р',\n          to: 'r'\n        }, {\n          from: 'с',\n          to: 's'\n        }, {\n          from: 'т',\n          to: 't'\n        }, {\n          from: 'ùúûüу',\n          to: 'u'\n        }, {\n          from: 'в',\n          to: 'v'\n        }, {\n          from: 'йы',\n          to: 'y'\n        }, {\n          from: 'з',\n          to: 'z'\n        }, {\n          from: 'æ',\n          to: 'ae'\n        }, {\n          from: 'ч',\n          to: 'ch'\n        }, {\n          from: 'щ',\n          to: 'sch'\n        }, {\n          from: 'ш',\n          to: 'sh'\n        }, {\n          from: 'ц',\n          to: 'ts'\n        }, {\n          from: 'я',\n          to: 'ya'\n        }, {\n          from: 'ю',\n          to: 'yu'\n        }, {\n          from: 'ж',\n          to: 'zh'\n        }, {\n          from: 'ъь',\n          to: ''\n        }\n      ]\n    };\n    _.defaults(opts, defaults);\n    fields = {\n      slugFrom: Array,\n      slugField: String,\n      distinct: Boolean,\n      createOnUpdate: Boolean,\n      maxLength: Number,\n      debug: Boolean\n    };\n    if (typeof opts.updateSlug !== \"function\") {\n      if (opts.updateSlug) {\n        opts.updateSlug = function() {\n          return true;\n        };\n      } else {\n        opts.updateSlug = function() {\n          return false;\n        };\n      }\n    }\n    check(opts, Match.ObjectIncluding(fields));\n    collection.before.insert(function(userId, doc) {\n      fsDebug(opts, 'before.insert function');\n      runSlug(doc, opts);\n    });\n    collection.before.update(function(userId, doc, fieldNames, modifier, options) {\n      var cleanModifier, cont, slugFromChanged;\n      fsDebug(opts, 'before.update function');\n      cleanModifier = function() {\n        if (_.isEmpty(modifier.$set)) {\n          return delete modifier.$set;\n        }\n      };\n      options = options || {};\n      if (options.multi) {\n        fsDebug(opts, \"multi doc update attempted, can't update slugs this way, leaving.\");\n        return true;\n      }\n      modifier = modifier || {};\n      modifier.$set = modifier.$set || {};\n      cont = false;\n      _.each(opts.slugFrom, function(slugFrom) {\n        if (stringToNested(doc, slugFrom) || (modifier.$set[slugFrom] != null) || stringToNested(modifier.$set, slugFrom)) {\n          return cont = true;\n        }\n      });\n      if (!cont) {\n        fsDebug(opts, \"no slugFrom fields are present (either before or after update), leaving.\");\n        cleanModifier();\n        return true;\n      }\n      slugFromChanged = false;\n      _.each(opts.slugFrom, function(slugFrom) {\n        var docFrom;\n        if ((modifier.$set[slugFrom] != null) || stringToNested(modifier.$set, slugFrom)) {\n          docFrom = stringToNested(doc, slugFrom);\n          if ((docFrom !== modifier.$set[slugFrom]) && (docFrom !== stringToNested(modifier.$set, slugFrom))) {\n            return slugFromChanged = true;\n          }\n        }\n      });\n      fsDebug(opts, slugFromChanged, 'slugFromChanged');\n      if (!stringToNested(doc, opts.slugField) && opts.createOnUpdate) {\n        fsDebug(opts, 'Update: Slug Field is missing and createOnUpdate is set to true');\n        if (slugFromChanged) {\n          fsDebug(opts, 'slugFrom field has changed, runSlug with modifier');\n          runSlug(doc, opts, modifier);\n        } else {\n          fsDebug(opts, 'runSlug to create');\n          runSlug(doc, opts, modifier, true);\n          cleanModifier();\n          return true;\n        }\n      } else {\n        if ((typeof opts.updateSlug === \"function\" ? opts.updateSlug(doc, modifier) : void 0) === false) {\n          fsDebug(opts, 'updateSlug is false, nothing to do.');\n          cleanModifier();\n          return true;\n        }\n        if (!slugFromChanged) {\n          fsDebug(opts, 'slugFrom field has not changed, nothing to do.');\n          cleanModifier();\n          return true;\n        }\n        runSlug(doc, opts, modifier);\n        cleanModifier();\n        return true;\n      }\n      cleanModifier();\n      return true;\n    });\n  });\n  runSlug = function(doc, opts, modifier, create) {\n    var baseField, combineFrom, defaultSlugGenerator, f, fieldSelector, finalSlug, from, i, index, indexField, limitSelector, ref, result, slugBase, slugGenerator, sortSelector;\n    if (modifier == null) {\n      modifier = false;\n    }\n    if (create == null) {\n      create = false;\n    }\n    fsDebug(opts, 'Begin runSlug');\n    fsDebug(opts, opts, 'Options');\n    fsDebug(opts, modifier, 'Modifier');\n    fsDebug(opts, create, 'Create');\n    combineFrom = function(doc, fields, modifierDoc) {\n      var fromValues;\n      fromValues = [];\n      _.each(fields, function(f) {\n        var val;\n        if (modifierDoc != null) {\n          if (stringToNested(modifierDoc, f)) {\n            val = stringToNested(modifierDoc, f);\n          } else {\n            val = stringToNested(doc, f);\n          }\n        } else {\n          val = stringToNested(doc, f);\n        }\n        if (val) {\n          return fromValues.push(val);\n        }\n      });\n      if (fromValues.length === 0) {\n        return false;\n      }\n      return fromValues.join('-');\n    };\n    from = create || !modifier ? combineFrom(doc, opts.slugFrom) : combineFrom(doc, opts.slugFrom, modifier.$set);\n    if (from === false) {\n      fsDebug(opts, \"Nothing to slug from, leaving.\");\n      return true;\n    }\n    fsDebug(opts, from, 'Slugging From');\n    slugBase = slugify(from, opts.transliteration, opts.maxLength);\n    if (!slugBase) {\n      return false;\n    }\n    fsDebug(opts, slugBase, 'SlugBase before reduction');\n    if (opts.distinct) {\n      slugBase = slugBase.replace(/(-\\d+)+$/, '');\n      fsDebug(opts, slugBase, 'SlugBase after reduction');\n      baseField = \"friendlySlugs.\" + opts.slugField + \".base\";\n      indexField = \"friendlySlugs.\" + opts.slugField + \".index\";\n      fieldSelector = {};\n      fieldSelector[baseField] = slugBase;\n      i = 0;\n      while (i < opts.distinctUpTo.length) {\n        f = opts.distinctUpTo[i];\n        fieldSelector[f] = doc[f];\n        i++;\n      }\n      sortSelector = {};\n      sortSelector[indexField] = -1;\n      limitSelector = {};\n      limitSelector[indexField] = 1;\n      result = collection.findOne(fieldSelector, {\n        sort: sortSelector,\n        fields: limitSelector,\n        limit: 1\n      });\n      fsDebug(opts, result, 'Highest indexed base found');\n      if ((result == null) || (result.friendlySlugs == null) || (result.friendlySlugs[opts.slugField] == null) || (result.friendlySlugs[opts.slugField].index == null)) {\n        index = 0;\n      } else {\n        index = result.friendlySlugs[opts.slugField].index + 1;\n      }\n      defaultSlugGenerator = function(slugBase, index) {\n        if (index === 0) {\n          return slugBase;\n        } else {\n          return slugBase + '-' + index;\n        }\n      };\n      slugGenerator = (ref = opts.slugGenerator) != null ? ref : defaultSlugGenerator;\n      finalSlug = slugGenerator(slugBase, index);\n    } else {\n      index = false;\n      finalSlug = slugBase;\n    }\n    fsDebug(opts, finalSlug, 'finalSlug');\n    if (modifier || create) {\n      fsDebug(opts, 'Set to modify or create slug on update');\n      modifier = modifier || {};\n      modifier.$set = modifier.$set || {};\n      modifier.$set.friendlySlugs = doc.friendlySlugs || {};\n      modifier.$set.friendlySlugs[opts.slugField] = modifier.$set.friendlySlugs[opts.slugField] || {};\n      modifier.$set.friendlySlugs[opts.slugField].base = slugBase;\n      modifier.$set.friendlySlugs[opts.slugField].index = index;\n      modifier.$set[opts.slugField] = finalSlug;\n      fsDebug(opts, modifier, 'Final Modifier');\n    } else {\n      fsDebug(opts, 'Set to update');\n      doc.friendlySlugs = doc.friendlySlugs || {};\n      doc.friendlySlugs[opts.slugField] = doc.friendlySlugs[opts.slugField] || {};\n      doc.friendlySlugs[opts.slugField].base = slugBase;\n      doc.friendlySlugs[opts.slugField].index = index;\n      doc[opts.slugField] = finalSlug;\n      fsDebug(opts, doc, 'Final Doc');\n    }\n    return true;\n  };\n  return fsDebug = function(opts, item, label) {\n    if (label == null) {\n      label = '';\n    }\n    if (!opts.debug) {\n      return;\n    }\n    if (typeof item === 'object') {\n      console.log(\"friendlySlugs DEBUG: \" + label + '↓');\n      return console.log(item);\n    } else {\n      return console.log(\"friendlySlugs DEBUG: \" + label + '= ' + item);\n    }\n  };\n};\n\nslugify = function(text, transliteration, maxLength) {\n  var lastDash, slug;\n  if (text == null) {\n    return false;\n  }\n  if (text.length < 1) {\n    return false;\n  }\n  text = text.toString().toLowerCase();\n  _.each(transliteration, function(item) {\n    return text = text.replace(new RegExp('[' + item.from + ']', 'g'), item.to);\n  });\n  slug = text.replace(/'/g, '').replace(/[^0-9a-z-]/g, '-').replace(/\\-\\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n  if (maxLength > 0 && slug.length > maxLength) {\n    lastDash = slug.substring(0, maxLength).lastIndexOf('-');\n    slug = slug.substring(0, lastDash);\n  }\n  return slug;\n};\n\nstringToNested = function(obj, path) {\n  var parts;\n  parts = path.split(\".\");\n  if (parts.length === 1) {\n    if ((obj != null) && (obj[parts[0]] != null)) {\n      return obj[parts[0]];\n    } else {\n      return false;\n    }\n  }\n  return stringToNested(obj[parts[0]], parts.slice(1).join(\".\"));\n};\n"]}